[
  {
    "instance_id": "instance_0",
    "gql_query": "MATCH (c:COUNTRY)-[s:Speaks]->(l:LANGUAGE) WHERE s.percentage > 50 RETURN c, l",
    "initial_nl": "Is there a language spoken in more than 50% of the population in any country? Return the city and the language.",
    "initial_nl_classification": "Level 2",
    "level_1": "Find all COUNTRY nodes connected by a Speaks relationship to LANGUAGE nodes where the relationship's percentage property is greater than 50, and return both the country and language nodes.",
    "level_2": "Which countries have a language spoken by more than 50% of their population, and what is that language?",
    "level_3": "Identify dominant languages within countries by analyzing linguistic distribution data to determine thresholds of majority usage.",
    "level_4": "Support language policy decisions or localization strategies by identifying countries where a single language holds significant majority status among the population.",
    "explanation": "The initial NL query focuses on the semantic meaning of the GQL without using graph-specific terms like 'nodes' or 'relationships', placing it at Level 2. Level 1 reintroduces explicit structural elements (node labels, relationship types, properties). Level 3 shifts to an analytical perspective, emphasizing the methodology of detecting dominant languages through threshold-based analysis. Level 4 elevates the insight to real-world applications, such as informing governmental policy or business localization efforts, highlighting strategic value.",
    "external_knowledge": "A language is considered dominant if spoken by more than 50% of a country's population, as indicated by the threshold in the query.",
    "meta": {}
  },
  {
    "instance_id": "instance_1",
    "gql_query": "MATCH (c:CITY)-[h:HasEthnicGroup]->(e:ETHNICITY) RETURN count(e) AS ethnic_group_count, avg(h.percentage) AS average_percentage",
    "initial_nl": "How many ethnic groups are present in each city, and what is the average percentage of the population for each ethnic group across all cities?",
    "initial_nl_classification": "Level 2",
    "level_1": "For each city node connected via a 'HasEthnicGroup' relationship to an ethnicity node, return the count of ethnicity nodes and the average value of the 'percentage' property on those relationships.",
    "level_2": "What is the total number of ethnic groups across all cities, and what is the average population percentage of these ethnic groups?",
    "level_3": "Analyze demographic diversity across cities by aggregating the number of represented ethnic groups and calculating the mean population share to identify overall patterns in multicultural distribution.",
    "level_4": "Support urban policy and resource allocation decisions by assessing the extent and scale of ethnic diversity across cities to promote inclusive community planning and services.",
    "explanation": "The initial natural language query focuses on the semantic meaning of the data (counting ethnic groups and averaging percentages) without referencing graph structures like nodes or relationships, placing it at Level 2. Level 1 explicitly describes the graph elements (CITY, ETHNICITY, HasEthnicGroup, percentage property). Level 2 rephrases this into a clear, non-technical question about the data. Level 3 shifts to the analytical intent—understanding patterns in demographic diversity. Level 4 elevates the purpose to strategic, real-world impact in urban planning and social equity, showing a progression from syntax to significance.",
    "external_knowledge": "The query counts all ethnic groups across cities and computes the average of their population percentages; 'mean population share' refers to the average of the percentage values in the HasEthnicGroup relationship.",
    "meta": {}
  },
  {
    "instance_id": "instance_2",
    "gql_query": "MATCH (l:LAKE) WHERE l.max_depth > 100 AND l.area > 500 RETURN l ORDER BY l.max_depth DESC",
    "initial_nl": "Find lakes with a maximum depth greater than 100 meters and an area larger than 500 square kilometers, ordered by maximum depth from deepest to shallowest.",
    "initial_nl_classification": "Level 2",
    "level_1": "Retrieve all 'LAKE' nodes in the graph where the 'max_depth' property is greater than 100 and the 'area' property exceeds 500, then return these nodes ordered by the 'max_depth' property in descending order.",
    "level_2": "Find lakes with a maximum depth greater than 100 meters and an area larger than 500 square kilometers, sorted from deepest to shallowest.",
    "level_3": "Identify and prioritize large, deep lakes to support hydrological studies focusing on water volume, thermal stratification, or ecosystem resilience in major freshwater bodies.",
    "level_4": "Support environmental conservation planning by highlighting significant lakes that may serve as critical water resources or biodiversity hotspots requiring targeted protection and management.",
    "explanation": "The progression moves from explicit graph syntax (Level 1: node labels and properties) to semantic clarity without technical terms (Level 2). Level 3 introduces the analytical intent—studying key physical characteristics of lakes for scientific insight. Level 4 elevates the purpose to real-world impact, emphasizing strategic environmental management and resource prioritization, thus reflecting increasing abstraction and domain relevance.",
    "external_knowledge": "Lakes must have a maximum depth greater than 100 meters and an area exceeding 500 square kilometers to qualify as large, deep lakes for hydrological analysis.",
    "meta": {}
  },
  {
    "instance_id": "instance_3",
    "gql_query": "MATCH (r1:RIVER)-[:FlowsInto]->(s:SEA)<-[:FlowsInto]-(r2:RIVER) WHERE r1.river_id <> r2.river_id RETURN r1.name AS river1_name, r2.name AS river2_name, s.name AS sea_name",
    "initial_nl": "Which two rivers flow into the same sea, and what are their names and the seas's name?",
    "initial_nl_classification": "Level 2",
    "level_1": "Find pairs of river nodes (r1:RIVER and r2:RIVER) that are connected via a FlowsInto relationship to the same sea node (s:SEA), where r1.river_id is not equal to r2.river_id, and return the names of r1, r2, and s.",
    "level_2": "Which two different rivers flow into the same sea, and what are the names of those rivers and the sea?",
    "level_3": "Identify co-destination patterns among rivers by analyzing which pairs share a common terminal sea, excluding self-pairs, to study hydrological convergence and potential basin interdependencies.",
    "level_4": "Support environmental planning and water resource management by revealing river systems that converge in the same sea, helping assess cumulative ecological impacts, pollution risks, or transboundary water governance needs.",
    "explanation": "The initial NL query focuses on the semantic meaning of the data without referencing graph structures (e.g., nodes, relationships), placing it at Level 2. Level 1 explicitly describes the graph syntax—node labels, relationship types, and filtering conditions. Level 2 rephrases this into natural language understandable to non-technical users, focusing on 'which rivers flow into the same sea.' Level 3 elevates the description to an analytical perspective, emphasizing the investigation of hydrological patterns and systemic relationships. Finally, Level 4 connects the query to real-world applications in environmental science and policy, highlighting strategic value in managing shared marine ecosystems.",
    "external_knowledge": "The query identifies pairs of distinct rivers (excluding self-pairs) that flow into the same sea, using river_id to ensure they are different, and returns their names along with the shared sea's name.",
    "meta": {}
  },
  {
    "instance_id": "instance_4",
    "gql_query": "MATCH (c:CITY)-[:LocatedIn]->(co:COUNTRY)-[:HasGovernment]->(g:GOVERNMENT_TYPE) WHERE c.population >= 1000000 AND c.population <= 5000000 AND g.name = 'Republic' RETURN c ORDER BY c.population ASC",
    "initial_nl": "List all cities with a population between 1 million and 5 million, located in countries with a government type of 'Republic', sorted by city population in ascending order.",
    "initial_nl_classification": "Level 2",
    "level_1": "Find all CITY nodes connected via a LocatedIn relationship to COUNTRY nodes, which are in turn connected by a HasGovernment relationship to GOVERNMENT_TYPE nodes where the name property is 'Republic', and where the CITY node has a population property between 1,000,000 and 5,000,000; return these CITY nodes ordered by their population in ascending order.",
    "level_2": "List all cities with a population between 1 million and 5 million that are located in countries with a government type of 'Republic', sorted by population from smallest to largest.",
    "level_3": "Identify mid-sized urban centers in republican-governed countries to analyze patterns in city size distribution within democratic political systems.",
    "level_4": "Support urban development policy and foreign investment planning by highlighting medium-population cities in stable republican nations that may offer strategic growth opportunities.",
    "explanation": "The progression moves from explicit graph syntax (Level 1: nodes, relationships, properties) to a clear semantic interpretation (Level 2: natural language without technical terms). Level 3 shifts to an analytical perspective, framing the query as part of a study on urban and political systems. Level 4 elevates the insight to strategic decision-making, emphasizing real-world applications in policy and investment—demonstrating increasing abstraction and domain relevance across levels.",
    "external_knowledge": "Mid-sized urban centers refer to cities with populations between 1 million and 5 million. Republican-governed countries are those with a government type of 'Republic'.",
    "meta": {}
  },
  {
    "instance_id": "instance_5",
    "gql_query": "MATCH (p1:PROVINCE)-[:Contains]->(b1:BOUNDARY), (p2:PROVINCE)-[:Contains]->(b2:BOUNDARY) WHERE b1.type = b2.type AND p1.province_id <> p2.province_id RETURN DISTINCT p1.name, p2.name",
    "initial_nl": "Identify any two provinces that contain the same type of boundary and list their names.",
    "initial_nl_classification": "Level 2",
    "level_1": "Find pairs of province nodes connected via 'Contains' relationships to boundary nodes where the boundary types are equal but the provinces have different province IDs, and return the distinct names of these provinces.",
    "level_2": "Identify any two provinces that contain the same type of boundary and list their names.",
    "level_3": "Explore spatial or administrative patterns by detecting provinces that share boundary types, to investigate potential regional connectivity or geographic clustering in the dataset.",
    "level_4": "Support regional planning and infrastructure development by identifying provinces with similar border characteristics, which may indicate shared logistical challenges or opportunities for cross-regional coordination.",
    "explanation": "The initial NL query focuses on the semantic meaning of the query without referencing graph elements like nodes or relationships, placing it at Level 2. Level 1 explicitly includes graph syntax (node labels, relationship types, properties). Level 3 shifts to the analytical intent—using shared boundary types to explore geographic or administrative patterns. Level 4 elevates the purpose to strategic decision-making in regional policy and infrastructure, reflecting real-world impact in governance or urban planning.",
    "external_knowledge": "The query identifies pairs of distinct provinces that share the same type of boundary, where 'same type' refers to the exact value of the 'type' attribute in the BOUNDARY entities connected to each province.",
    "meta": {}
  },
  {
    "instance_id": "instance_6",
    "gql_query": "MATCH (r:RIVER)-[:FlowsInto]->(s:SEA) WHERE r.length > 1000 RETURN r ORDER BY r.length DESC",
    "initial_nl": "Retrieve all rivers with a length greater than 1000 kilometers that flow into a sea, sorted by river length in descending order.",
    "initial_nl_classification": "Level 2",
    "level_1": "Find all nodes labeled 'RIVER' that have a relationship 'FlowsInto' directed to nodes labeled 'SEA', where the river's 'length' property is greater than 1000, and return these river nodes ordered by the 'length' property in descending order.",
    "level_2": "Retrieve all rivers longer than 1000 kilometers that flow into a sea, sorted from longest to shortest.",
    "level_3": "Identify and rank major rivers exceeding 1000 km in length based on their connectivity to seas to analyze geographic patterns in large river systems.",
    "level_4": "Support environmental and infrastructure planning by highlighting the longest rivers flowing into seas, which may influence navigation routes, ecological conservation priorities, or water resource management strategies.",
    "explanation": "The initial NL query focuses on the semantic meaning of the data retrieval without referencing graph-specific elements like nodes or relationships, placing it at Level 2. Level 1 reintroduces explicit graph terminology (labels, relationships, properties). Level 3 shifts to the analytical intent—studying large river systems and their geographic behavior. Level 4 elevates the context to real-world applications in environmental and strategic planning, emphasizing business or domain impact. This progression moves from syntactic structure to strategic insight.",
    "external_knowledge": "Major rivers are defined as those exceeding 1000 kilometers in length; connectivity to seas refers to rivers that directly flow into a sea, as specified by the FlowsInto relationship.",
    "meta": {}
  },
  {
    "instance_id": "instance_7",
    "gql_query": "MATCH (c:CITY)-[:LocatedIn]->(country:COUNTRY) RETURN country.name AS country_name, count(c) AS city_count, sum(c.population) AS total_population ORDER BY country_name",
    "initial_nl": "How many cities are located in each country, and what is the total population of cities per country?",
    "initial_nl_classification": "Level 2",
    "level_1": "Find all CITY nodes connected to COUNTRY nodes via the 'LocatedIn' relationship, and for each COUNTRY node, return the country name, the count of connected CITY nodes, and the sum of the population property values of those cities, ordered by the country name.",
    "level_2": "How many cities are located in each country, and what is the total population of cities per country?",
    "level_3": "Aggregate city-level demographic data by country to analyze geographic distribution patterns and urban concentration across nations.",
    "level_4": "Support national infrastructure and resource allocation planning by providing insights into urban density and population distribution across countries.",
    "explanation": "The progression moves from syntactic graph components (Level 1: nodes, relationships, properties) to a semantically equivalent natural language question (Level 2). Level 3 shifts to the analytical intent—using aggregation to study spatial and demographic patterns. Level 4 elevates the purpose to strategic decision-making, emphasizing real-world applications in policy and planning. The initial NL query focuses on semantic meaning without referencing graph structures, placing it at Level 2.",
    "external_knowledge": "The query counts cities and sums their populations for each country, providing the exact number of cities and total population per country to analyze urban concentration.",
    "meta": {}
  },
  {
    "instance_id": "instance_8",
    "gql_query": "MATCH (r:RIVER)-[:FlowsInto]->(o:OCEAN) WHERE o.name = 'Pacific Ocean' RETURN r.name",
    "initial_nl": "Which rivers flow into the ocean named 'Pacific Ocean'?",
    "initial_nl_classification": "Level 2",
    "level_1": "Find all nodes labeled 'RIVER' that have a 'FlowsInto' relationship directed to a node labeled 'OCEAN' where the 'name' property of the OCEAN node is 'Pacific Ocean', and return the 'name' property of the RIVER nodes.",
    "level_2": "Which rivers flow into the ocean named 'Pacific Ocean'?",
    "level_3": "Identify river systems connected to the Pacific Ocean to analyze hydrological networks and potential pathways for waterborne transport or ecological impact.",
    "level_4": "Support environmental planning and disaster management strategies by mapping freshwater sources contributing to the Pacific Ocean, aiding in pollution control, fisheries management, and climate resilience initiatives.",
    "explanation": "The initial NL query focuses on the semantic meaning of the data without referencing graph structures (e.g., nodes, relationships), placing it at Level 2. Level 1 explicitly includes graph syntax such as node labels, relationship types, and properties. Level 2 rephrases this into natural language understandable to non-technical users. Level 3 shifts to an analytical perspective, emphasizing the investigative strategy behind identifying river-ocean connectivity. Level 4 elevates the insight to real-world applications in environmental science and policy, highlighting strategic domain value.",
    "external_knowledge": "The query specifically identifies rivers that flow into the Pacific Ocean, which is explicitly named in the database. Only direct river-to-ocean flow relationships are considered.",
    "meta": {}
  },
  {
    "instance_id": "instance_9",
    "gql_query": "MATCH (p:PROVINCE) WHERE p.population < 1000000 AND p.area > 10000 RETURN p.name ORDER BY p.area ASC",
    "initial_nl": "Retrieve the names of provinces with a population less than 1 million and an area greater than 10,000 square kilometers, sorted by area in ascending order.",
    "initial_nl_classification": "Level 2",
    "level_1": "Find all nodes labeled as PROVINCE that have a population property less than 1000000 and an area property greater than 10000, then return the name property of these nodes ordered by the area property in ascending order.",
    "level_2": "List the names of provinces with fewer than 1 million people and an area exceeding 10,000 square kilometers, sorted from smallest to largest by area.",
    "level_3": "Identify sparsely populated but geographically large provinces to analyze regional density patterns and explore potential outliers in land use or administrative efficiency.",
    "level_4": "Support regional planning and resource allocation decisions by highlighting underpopulated yet expansive provinces that may require targeted infrastructure investment or policy intervention.",
    "explanation": "The progression moves from syntactic graph elements (Level 1), which explicitly references node labels and properties, to a semantically equivalent natural language statement without graph jargon (Level 2). Level 3 shifts focus to the analytical intent—investigating geographic and demographic anomalies. Finally, Level 4 frames the query in terms of strategic governance and public policy impact, emphasizing real-world decision-making value.",
    "external_knowledge": "Sparsely populated means fewer than 1 million people; geographically large means an area exceeding 10,000 square kilometers. Provinces are sorted by area ascending to identify outliers in land use or administrative efficiency.",
    "meta": {}
  },
  {
    "instance_id": "instance_10",
    "gql_query": "MATCH (c:COUNTRY)-[:HasForest]->(f:FOREST) RETURN c.name AS country, AVG(f.area) AS average_forest_area, SUM(f.area) AS total_forest_area ORDER BY total_forest_area DESC LIMIT 1",
    "initial_nl": "which country has the largest total forest area? What is the average area of forests and total forest area in that country?",
    "initial_nl_classification": "Level 2",
    "level_1": "Find a COUNTRY node connected via the HasForest relationship to FOREST nodes, retrieve the country's name, compute the average of the 'area' property across related FOREST nodes, sum the 'area' property values of all connected FOREST nodes, order the results by the total forest area in descending order, and return only the top result.",
    "level_2": "Which country has the largest total forest area, and what are the average forest area and total forest area in that country?",
    "level_3": "Identify the country with the most extensive forest coverage by aggregating forest areas and analyze the distribution of forest sizes within that country to understand spatial concentration patterns.",
    "level_4": "Determine the nation with the greatest forest resource capacity to inform environmental conservation strategies, carbon sequestration potential, and sustainable land-use planning on a global scale.",
    "explanation": "The initial NL query focuses on the semantic meaning of the query without referencing graph structures (e.g., nodes or relationships), placing it at Level 2. Level 1 introduces explicit graph elements like node labels (COUNTRY, FOREST), relationship type (HasForest), and property operations. Level 2 rephrases this into a natural question understandable to non-technical users. Level 3 shifts to the analytical intent—understanding not just 'which' but 'why' such aggregation matters in exploring geographic patterns. Finally, Level 4 elevates the insight to strategic, real-world applications in environmental policy and sustainability, emphasizing domain impact rather than data mechanics.",
    "external_knowledge": "The country with the largest total forest area is determined by summing all forest areas per country. The average forest area in that country is also calculated to assess spatial concentration patterns.",
    "meta": {}
  },
  {
    "instance_id": "instance_11",
    "gql_query": "MATCH (c:CITY) WHERE c.area > 500 AND c.latitude >= 40 AND c.latitude <= 50 RETURN c ORDER BY c.longitude ASC",
    "initial_nl": "List cities having an area larger than 500 square kilometers and a latitude between 40 and 50 degrees, ordered by longitude from west to east.",
    "initial_nl_classification": "Level 2",
    "level_1": "Find all nodes labeled as CITY that have a property 'area' greater than 500, and whose 'latitude' property is between 40 and 50, inclusive, then return these nodes ordered by their 'longitude' property in ascending order.",
    "level_2": "List cities with an area larger than 500 square kilometers and located between latitudes 40 and 50 degrees, sorted from west to east based on increasing longitude.",
    "level_3": "Identify and analyze geographically dispersed cities of significant size within a specific mid-latitude band to study spatial distribution patterns across a longitudinal gradient.",
    "level_4": "Support urban development or logistics planning by identifying large cities in a target latitude zone, enabling strategic decisions about regional investments, transportation networks, or market expansion from west to east.",
    "explanation": "The initial NL query focuses on the semantic meaning of the data conditions without referencing graph structures (e.g., nodes, labels), placing it at Level 2. Level 1 explicitly includes graph terminology such as node labels (CITY) and properties. Level 2 rephrases this into natural geographic terms understandable to non-technical users. Level 3 shifts to an analytical perspective, emphasizing the investigation of spatial patterns. Level 4 connects the query to real-world strategic applications in urban planning or business expansion, highlighting domain impact and decision-making value.",
    "external_knowledge": "Significant size refers to cities with an area greater than 500 square kilometers; the specific mid-latitude band is between 40 and 50 degrees latitude, and west-to-east ordering follows increasing longitude.",
    "meta": {}
  },
  {
    "instance_id": "instance_12",
    "gql_query": "MATCH (r:RIVER)-[:FlowsInto]->(o:OCEAN) WITH o, count(r) AS tributary_count RETURN o.name AS ocean_name, tributary_count ORDER BY tributary_count DESC LIMIT 1",
    "initial_nl": "Count the number of rivers that flow into each ocean, and identify the ocean with the highest number of tributaries.",
    "initial_nl_classification": "Level 2",
    "level_1": "Find all river nodes connected to ocean nodes via the 'FlowsInto' relationship, group by ocean, count the number of incoming river relationships per ocean, return the ocean name and the count, then sort in descending order and limit to the top result.",
    "level_2": "Which ocean receives the most rivers flowing into it, and how many rivers flow into it?",
    "level_3": "Analyze the distribution of river inflows across oceans to determine which ocean acts as the primary endpoint for river systems, using aggregation and ranking to identify dominant patterns in hydrological connectivity.",
    "level_4": "Identify the ocean that serves as the major drainage hub for global river networks to support environmental impact assessments, climate modeling, or resource management strategies related to freshwater inflow and marine ecosystem health.",
    "explanation": "The initial natural language query describes the logical operation (counting and identifying maximum) without referencing graph elements like nodes or relationships, placing it at Level 2. Level 1 explicitly includes graph syntax such as node labels (RIVER, OCEAN), relationship types (:FlowsInto), and query structure (WITH, RETURN, ORDER BY). Level 3 shifts focus to the analytical strategy—examining hydrological patterns through aggregation and ranking. Level 4 elevates the insight to real-world applications in environmental science and policy, emphasizing strategic value over technical or computational details.",
    "external_knowledge": "The primary endpoint ocean is determined by the highest count of rivers flowing into it; the query returns the ocean with the maximum tributary_count, which is the number of rivers (r) flowing into each ocean (o).",
    "meta": {}
  },
  {
    "instance_id": "instance_13",
    "gql_query": "MATCH (m:MOUNTAIN)<-[:HasMountain]-(p:PROVINCE)-[:PartOf]->(r:REGION)-[:PartOf]->(c:CONTINENT) WHERE c.area > 10000000 RETURN m",
    "initial_nl": "List the mountains in provinces that are part of regions which belong to continents with an area greater than 10 million square kilometers.",
    "initial_nl_classification": "Level 2",
    "level_1": "Find all MOUNTAIN nodes connected via a HasMountain relationship to PROVINCE nodes, where each PROVINCE is linked by a PartOf relationship to a REGION, which in turn is linked by a PartOf relationship to a CONTINENT node with an area property greater than 10,000,000; return the MOUNTAIN nodes.",
    "level_2": "List the mountains located in provinces that are part of regions within continents having an area larger than 10 million square kilometers.",
    "level_3": "Identify mountain formations in provinces across large continental landmasses to analyze geographical distribution patterns based on continental size thresholds.",
    "level_4": "Support environmental planning and resource allocation by identifying significant mountain regions in the world's largest continents for conservation or tourism development strategies.",
    "explanation": "The initial natural language query focuses on the semantic meaning of the data relationships without referencing graph-specific syntax like labels or relationships explicitly, placing it at Level 2. Level 1 reintroduces explicit graph elements (node types, relationship types, properties). Level 3 shifts to the analytical intent—examining geographic patterns using size-based filtering. Level 4 elevates the purpose to strategic decision-making in environmental or economic domains, emphasizing real-world impact.",
    "external_knowledge": "Large continental landmasses refer to continents with an area greater than 10 million square kilometers. The query specifically targets mountains in provinces within such continents.",
    "meta": {}
  }
]